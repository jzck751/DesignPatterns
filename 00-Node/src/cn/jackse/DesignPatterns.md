# UML

## 类图概述



## 类图作用



## 类图表示法

### 类的表示方式

### 类与类之间关系的表示方式

耦合性最低的是依赖关系、耦合性最强的是继承和实现关系

### 关联关系

- 关联关系是对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系
- 如老师和学生、师傅和徒弟

#### 单向关联

#### 双向关联

#### 自关联

### 聚合关系

### 组合关系

### 依赖关系

### 继承关系

### 实现关系



# 软件设计原则

## 开闭原则



## 里氏代换原则



## 依赖

## 倒转原则



## 接口隔离原则



## 迪米特法则



## 合成复用原则



# 创建者模式



## 单例设计模式

> 单例模式分为两种：
>
> ​		饿汉式：类加载就会导致该单实例对象被创建
>
> ​		懒汉式：类加载不会导致该但是离对象被创建，而是首次使用该对象时才会创建



### 单例模式的实现

#### 饿汉式-方式1（静态变量方式）

- `说明`：该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。

#### 饿汉式-方式2（静态代码块）

- `说明`：该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是随着类的加载而创建，所以和饿汉式的方式1基本一样，当然该方式也存在内存浪费问题。



#### 懒汉式-方式1（线程不安全）

#### 懒汉式-方式2（线程安全-添加synchronized）

#### 懒汉式-方式3（双重检查锁）

- 对于**getInstance()**方法来说，绝大部分操作都是读操作，读操作是线程安全的，所以我们没必要让每个线程必须持有锁才能调用该方法，我们需要调整枷锁的时机。

- 双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。

    要解决双重检查锁模式带来空指针异常的问题，只需要使用 `volatile` 关键字, `volatile` 关键字可以保证可见性和有序性。

#### 懒汉式-方式4（静态内部类方式）



### 存在的问题

##### 问题演示

破坏单例模式：

上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。



- 序列化反序列化
- 反射



##### 问题的解决

- 序列化、反序列化破坏单例模式的解决办法：

    

    在Singleton类中添加`readResolve()`方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。

    

    ```java
    /**
         * 当进行反序列化时，会自动调用该方法，将该方法的返回值直接返回
         * @return
         */
    public Object readResolve() {
        return SingletonHolder.INSTANCE;
    }
    ```

    

- 反射破坏单例模式解决方式：

    

    ```java
    public class Singleton implements Serializable {
    
        private static boolean flag = false;
    
        /**
         * 1.私有构造方法
         */
        private Singleton() {
            synchronized (Singleton.class) {
                //判断flag的值是否为true,如果为true那么非第一次访问，抛出一个运行时异常
                if (flag) {
                    throw new RuntimeException("不能创建多个对象");
                }
                //如果flag的值为false，那么是第一次访问，我们将flag设置为true
                flag = true;
            }
        }
    
        /**
         * 2.定义静态内部类
         */
        private static class SingletonHolder {
            //在内部类中声明并初始化外部类的对象
            private static final Singleton INSTANCE = new Singleton();
        }
    
        /**
         * 3.提供外界访问方法
         */
        public static Singleton getInstance() {
            return SingletonHolder.INSTANCE;
        }
    }
    ```

    



### 枚举方式

- 枚举方式属于饿汉式方式
- 枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所有单例实现中唯一一种不会被破坏的单例实现模式。



### Jdk源码解析-Runtime类

Runtime类就是使用的单例设计模式



![image-20211027213338363](https://gitee.com/jzy0101/image/raw/master/img/202110272133452.png)



- 从图片中我们可以看出Runtime类是使用的饿汉式（静态属性）方式来实现单例模式的。

## 工厂方法模式



## 抽象工厂模式



## 原型模式



## 建造者模式



# 结构型模式





# 行为型模式





# 自定义Spring框架















